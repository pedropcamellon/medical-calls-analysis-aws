import boto3
import json


def lambda_handler(event, context):
    """
    AWS Lambda function to process a transcript JSON file from an S3 bucket,
    summarize its content using Amazon Bedrock, and store the summary back
    in the S3 bucket.

    Parameters:
    event (dict): The event data from S3, including the bucket name and object key.
    context: The runtime information of the Lambda function.

    Returns:
    dict: A response object with a status code and a message indicating success or failure.
    """

    bucket = event["Records"][0]["s3"]["bucket"]["name"]
    key = event["Records"][0]["s3"]["object"]["key"]

    print(f"Processing file {key} from bucket {bucket}.")

    # One of a few different checks to ensure we don't end up in a recursive loop.
    if ".json" not in key:
        print("This demo only works with transcription JSON files.")
        return {
            "statusCode": 400,
            "body": json.dumps("This demo only works with transcription JSON files."),
        }

    # Create a Boto3 client for the S3 service
    s3_client = boto3.client("s3", region_name="us-east-1")
    bedrock_client = boto3.client("bedrock-runtime", region_name="us-east-1")

    try:
        response = s3_client.get_object(Bucket=bucket, Key=key)

        file_content = response["Body"].read().decode("utf-8")

        transcript = extract_transcript_from_textract(file_content)

        print(f"Successfully read file {key} from bucket {bucket}.")

        print(f"Transcript: {transcript}")

        summary = bedrock_summarisation(transcript, bedrock_client)

        print(f"Summary: {summary}")

        filename = (
            key.split("/")[-1]
            .replace("transcription-job", "summarization-job")
            .replace(".json", ".txt")
        )

        # Create the summary key with proper path
        summary_key = f"summaries/{filename}"

        s3_client.put_object(
            Bucket=bucket, Key=summary_key, Body=summary, ContentType="text/plain"
        )

        print(f"Summary file {summary_key} created in bucket {bucket}.")

    except Exception as e:
        print(f"Error occurred: {e}")
        return {"statusCode": 500, "body": json.dumps(f"Error occurred: {e}")}

    return {
        "statusCode": 200,
        "body": json.dumps(
            f"Successfully summarized {key} from bucket {bucket}. Summary: {summary}"
        ),
    }


def extract_transcript_from_textract(file_content):
    """
    Extracts a transcript from the JSON output of Amazon Textract.

    This takes the JSON output of Amazon Textract and converts it into a human-readable
    transcript format, with each speaker on a new line and the speaker label added at the
    start of each line.

    :param file_content: The JSON content of the Textract output file
    :return: The human-readable transcript
    """
    transcript_json = json.loads(file_content)

    output_text = ""
    current_speaker = None

    items = transcript_json["results"]["items"]

    # Iterate through the content word by word:
    for item in items:
        speaker_label = item.get("speaker_label", None)
        content = item["alternatives"][0]["content"]

        # Start the line with the speaker label:
        if speaker_label is not None and speaker_label != current_speaker:
            current_speaker = speaker_label
            output_text += f"\n{current_speaker}: "

        # Add the speech content:
        if item["type"] == "punctuation":
            output_text = output_text.rstrip()  # Remove the last space

        output_text += f"{content} "

    return output_text


def bedrock_summarisation(transcript, bedrock_client):
    """
    Summarizes a conversation transcript using Amazon Bedrock.

    This function reads a prompt template from a file, fills it with the provided
    transcript and predefined topics, and sends it to the Amazon Bedrock model for
    text generation. The function then retrieves and returns the generated summary
    text.

    :param transcript: The conversation transcript to be summarized.
    :param bedrock_client: A client for invoking the Amazon Bedrock text generation model.
    :return: A summary of the conversation generated by the Bedrock model.
    """

    print("Starting Bedrock summarization...")

    prompt = f"""I need to summarize a conversation. The transcript of the 
        conversation is between the <data> XML like tags.

        <data>
        {transcript}
        </data>

        The summary must contain a one word sentiment analysis, and 
        a list of issues, problems or causes of friction
        during the conversation. 
        
        The output must be provided in JSON format using the following fields: 
        
        - "sentiment": <sentiment>,
        - "issues": [
                - "topic": ["charges"|"location"|"availability"]
                - "summary": [issue_summary]
            ]
        """

    kwargs = {
        "modelId": "amazon.titan-text-express-v1",
        "contentType": "application/json",
        "accept": "*/*",
        "body": json.dumps(
            {
                "inputText": prompt,
                "textGenerationConfig": {
                    "maxTokenCount": 2048,
                    "stopSequences": [],
                    "temperature": 0,
                    "topP": 0.9,
                },
            }
        ),
    }

    response = bedrock_client.invoke_model(**kwargs)

    summary = (
        json.loads(response.get("body").read()).get("results")[0].get("outputText")
    )

    return summary
